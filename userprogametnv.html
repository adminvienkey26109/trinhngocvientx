<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Nh·∫≠p key ƒë·ªÉ v√†o game</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 30px auto;
      text-align: center;
      background: url('https://i.imgur.com/1JdFvXb.jpg') no-repeat center center fixed;
      background-size: cover;
      color: white;
    }
    input, button {
      padding: 10px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      margin-bottom: 10px;
    }
    input {
      width: 80%;
    }
    button {
      margin: 5px;
      cursor: pointer;
      border: 2px solid #1abc9c;
      background: transparent;
      color: #1abc9c;
      font-weight: bold;
      transition: 0.3s;
      text-shadow: 0 0 5px #1abc9c;
    }
    button:hover {
      background-color: #1abc9c;
      color: #fff;
      text-shadow: none;
      box-shadow: 0 0 8px #16a085;
    }
    #status {
      margin-top: 20px;
      font-weight: bold;
      font-size: 18px;
      text-shadow: 0 0 5px #000;
    }
    #gameMenu {
      margin-top: 30px;
      display: none;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .game-btn {
      border: 2px solid #1abc9c;
      color: #1abc9c;
      padding: 10px 15px;
      border-radius: 10px;
      font-weight: bold;
      width: 100px;
      box-shadow: 0 0 8px #16a085;
      cursor: pointer;
      transition: 0.3s;
      position: relative;
      overflow: hidden;
    }
    .game-btn::before {
      content: '';
      position: absolute;
      width: 150%;
      height: 150%;
      background: linear-gradient(45deg, transparent, #1abc9c, transparent);
      animation: ledEffect 3s linear infinite;
      top: -50%;
      left: -50%;
      opacity: 0.6;
      border-radius: 10px;
      pointer-events: none;
    }
    .game-btn span {
      position: relative;
      z-index: 1;
      text-shadow: 0 0 10px #1abc9c;
    }
    @keyframes ledEffect {
      0% { transform: rotate(0deg) translateX(-100%); }
      100% { transform: rotate(360deg) translateX(100%); }
    }
    #logoutBtn {
      margin-top: 15px;
      display: none;
      background-color: #e74c3c;
      border-color: #c0392b;
      color: white;
      box-shadow: none;
      text-shadow: none;
    }
    #logoutBtn:hover {
      background-color: #c0392b;
    }
    #adminMenuBtn {
      position: fixed;
      top: 15px;
      left: 15px;
      background: #1abc9c;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      cursor: pointer;
      font-weight: bold;
      color: white;
      box-shadow: 0 0 10px #16a085;
      z-index: 1000;
    }
    #adminContacts {
      position: fixed;
      top: 50px;
      left: 15px;
      background: rgba(26, 188, 156, 0.9);
      border-radius: 10px;
      padding: 10px;
      display: none;
      z-index: 999;
      width: 200px;
      text-align: left;
      box-shadow: 0 0 15px #16a085;
    }
    #adminContacts a {
      display: block;
      color: white;
      margin: 5px 0;
      font-weight: bold;
      text-decoration: none;
      text-shadow: 0 0 3px black;
    }
    #note {
      margin-top: 40px;
      font-size: 14px;
      background: rgba(0,0,0,0.5);
      padding: 15px;
      border-radius: 10px;
      font-weight: bold;
      color: #f1c40f;
      text-shadow: 0 0 5px black;
    }
    .countdown {
      font-weight: bold;
      font-size: 20px;
      margin-top: 15px;
      color: #1abc9c;
      text-shadow: 0 0 10px #16a085;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { text-shadow: 0 0 10px #16a085; }
      50% { text-shadow: 0 0 20px #1abc9c; }
    }
  </style>
</head>
<body>

<button id="adminMenuBtn" onclick="toggleAdminContacts()">Menu Admin</button>
<div id="adminContacts">
  <a href="https://facebook.com/admin1" target="_blank">Admin 1</a>
  <a href="https://facebook.com/admin2" target="_blank">Admin 2</a>
  <a href="https://facebook.com/admin3" target="_blank">Admin 3</a>
</div>

<h2>üéÆ V√†o game b·∫±ng key</h2>
<p>Nh·∫≠p key ƒë·ªÉ k√≠ch ho·∫°t, ho·∫∑c b·∫°n ƒë√£ ƒëƒÉng nh·∫≠p r·ªìi.</p>
<input type="text" id="userKey" placeholder="Nh·∫≠p key b·∫°n c√≥..."><br>
<button onclick="checkKey()">‚úÖ Ki·ªÉm tra key</button>
<p id="status"></p>

<div id="gameMenu">
  <h3>Ch·ªçn tool b·∫°n mu·ªën d√πng:</h3>
  <div id="gamesButtons"></div>
  <p id="countdown" class="countdown"></p>
  <button id="logoutBtn" onclick="logout()">üö™ ƒêƒÉng xu·∫•t</button>
</div>

<!-- Tool hi·ªÉn th·ªã t·∫°i ƒë√¢y -->
<div id="toolContainer" style="margin-top: 30px;">
  <div id="tool1Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 1</h3><p>ƒê√¢y l√† n·ªôi dung tool 1.</p>
    <script><!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D·ª± ƒëo√°n T√†i X·ªâu By Ngoc Vien</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f4;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 600px;
            text-align: center;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        .buttons {
            margin-bottom: 20px;
        }
        .buttons button {
            padding: 10px 20px;
            font-size: 18px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .buttons .btn-tai {
            background-color: #4CAF50;
            color: white;
        }
        .buttons .btn-tai:hover {
            background-color: #45a049;
        }
        .buttons .btn-xiu {
            background-color: #f44336;
            color: white;
        }
        .buttons .btn-xiu:hover {
            background-color: #da190b;
        }
        .buttons .btn-clear {
            background-color: #ffc107;
            color: #333;
        }
        .buttons .btn-clear:hover {
            background-color: #e0a800;
        }
        .buttons .btn-predict {
            background-color: #007bff;
            color: white;
        }
        .buttons .btn-predict:hover {
            background-color: #0056b3;
        }

        #result-display {
            font-size: 24px;
            margin-bottom: 20px;
            min-height: 30px;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #e9e9e9;
            border-radius: 5px;
            word-wrap: break-word;
        }
        #prediction-display {
            font-size: 28px;
            font-weight: bold;
            margin-top: 20px;
            color: #007bff;
            min-height: 35px;
        }
        #pattern-analysis {
            text-align: left;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        #pattern-analysis h2 {
            color: #555;
            margin-bottom: 15px;
        }
        #pattern-analysis ul {
            list-style-type: none;
            padding: 0;
        }
        #pattern-analysis ul li {
            background-color: #e0f7fa;
            border-left: 5px solid #00bcd4;
            margin-bottom: 8px;
            padding: 10px;
            border-radius: 4px;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #pattern-analysis ul li.no-pattern {
            background-color: #ffebee;
            border-left: 5px solid #f44336;
            color: #d32f2f;
        }
        .pattern-percentage {
            font-weight: bold;
            color: #007bff;
        }

        /* Error message styling */
        .error-message {
            background-color: #ffdddd;
            color: #d8000c;
            padding: 10px;
            border: 1px solid #d8000c;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none; /* Hidden by default */
            animation: fadeOut 5s forwards; /* Animation to fade out */
        }

        @keyframes fadeOut {
            0% { opacity: 1; display: block; }
            80% { opacity: 1; display: block; }
            100% { opacity: 0; display: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>D·ª± ƒëo√°n T√†i X·ªâu</h1>
        <div class="buttons">
            <button class="btn-tai" onclick="addResult('t')">T√†i</button>
            <button class="btn-xiu" onclick="addResult('x')">X·ªâu</button>
            <button class="btn-clear" onclick="clearResults()">X√≥a</button>
            <button class="btn-predict" onclick="predictNext()">D·ª± ƒëo√°n</button>
        </div>
        <div id="error-message" class="error-message"></div>
        <div id="result-display"></div>
        <div id="prediction-display"></div>
        <div id="pattern-analysis">
            <h2>C√°c lo·∫°i c·∫ßu c√≥ th·ªÉ x·∫£y ra:</h2>
            <ul id="patterns-list">
                </ul>
        </div>
    </div>

    <script>
        let results = "";
        let errorTimeout; // To store the timeout ID for error messages
        const patternsList = document.getElementById('patterns-list');
        const predictionDisplay = document.getElementById('prediction-display');
        const errorMessageDiv = document.getElementById('error-message');

        function showErrorMessage(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';

            // Clear any existing timeout to restart the fadeOut animation
            clearTimeout(errorTimeout);

            // Set a new timeout to hide and fade out the message after 5 seconds
            errorTimeout = setTimeout(() => {
                errorMessageDiv.style.display = 'none';
            }, 5000);
        }

        function addResult(type) {
            results += type;
            document.getElementById('result-display').innerText = results.toUpperCase().split('').join('-');
            analyzePatterns();
            predictionDisplay.innerText = ""; // Clear previous prediction
            errorMessageDiv.style.display = 'none'; // Hide error message if adding results
        }

        function clearResults() {
            results = "";
            document.getElementById('result-display').innerText = "";
            patternsList.innerHTML = "";
            predictionDisplay.innerText = "";
            errorMessageDiv.style.display = 'none'; // Hide error message on clear
            clearTimeout(errorTimeout); // Clear any pending error message timeout
        }

        function predictNext() {
            if (results.length === 0) {
                showErrorMessage("Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt k·∫øt qu·∫£ T√†i ho·∫∑c X·ªâu ƒë·ªÉ d·ª± ƒëo√°n.");
                predictionDisplay.innerText = ""; // Clear any old prediction
                return;
            }
            if (results.length < 2) { // Minimum length for some meaningful pattern analysis
                showErrorMessage("Chu·ªói k·∫øt qu·∫£ qu√° ng·∫Øn ƒë·ªÉ ƒë∆∞a ra d·ª± ƒëo√°n c√≥ √Ω nghƒ©a. Vui l√≤ng nh·∫≠p th√™m.");
                predictionDisplay.innerText = "";
                return;
            }

            // Clear any error message before starting prediction
            errorMessageDiv.style.display = 'none';

            const potentialPredictions = []; // Stores [{ name: "C·∫ßu X", percentage: 90, prediction: 't', priority: 5 }]

            // Helper functions
            function checkConsecutive(char, count, str = results) {
                const regex = new RegExp(`${char}{${count}}$`);
                return regex.test(str);
            }

            function checkAlternating(subStr) {
                if (!subStr || subStr.length < 2) return 0;
                let matches = 0;
                for (let i = 0; i < subStr.length - 1; i++) {
                    if (subStr[i] !== subStr[i+1]) {
                        matches++;
                    }
                }
                return (matches / (subStr.length - 1)) * 100;
            }

            function getSequenceMatchPercentage(sequence, str = results) {
                if (str.length < sequence.length) return 0;
                const sub = str.slice(-sequence.length);
                let matches = 0;
                for (let i = 0; i < sequence.length; i++) {
                    if (sub[i] === sequence[i]) {
                        matches++;
                    }
                }
                return (matches / sequence.length) * 100;
            }

            function countTrailing(char, str = results) {
                let count = 0;
                for (let i = str.length - 1; i >= 0; i--) {
                    if (str[i] === char) {
                        count++;
                    } else {
                        break;
                    }
                }
                return count;
            }

            // Function to add a prediction with its priority
            function addPrediction(name, percentage, prediction, priority = 1) {
                potentialPredictions.push({ name, percentage, prediction, priority });
            }

            // --- Logic for predicting based on common patterns ---
            const lastChar = results.slice(-1);
            const secondLastChar = results.slice(-2, -1);
            const thirdLastChar = results.slice(-3, -2);
            const fourthLastChar = results.slice(-4, -3); // Useful for some patterns

            // 1. Long Streaks (C·∫ßu B·ªát) - Highest Priority
            const trailingT = countTrailing('t');
            const trailingX = countTrailing('x');

            if (trailingT >= 5) {
                addPrediction(`C·∫ßu b·ªát T√†i (B·ªát ${trailingT} l·∫ßn)`, 100, 't', 12); // Very high priority
            } else if (trailingX >= 5) {
                addPrediction(`C·∫ßu b·ªát X·ªâu (B·ªát ${trailingX} l·∫ßn)`, 100, 'x', 12);
            } else if (trailingT === 4) {
                addPrediction(`C·∫ßu b·ªát T√†i (B·ªát ${trailingT} l·∫ßn)`, 100, 't', 10);
            } else if (trailingX === 4) {
                addPrediction(`C·∫ßu b·ªát X·ªâu (B·ªát ${trailingX} l·∫ßn)`, 100, 'x', 10);
            } else if (trailingT === 3) {
                addPrediction(`C·∫ßu b·ªát T√†i (B·ªát ${trailingT} l·∫ßn)`, 100, 't', 8);
            } else if (trailingX === 3) {
                addPrediction(`C·∫ßu b·ªát X·ªâu (B·ªát ${trailingX} l·∫ßn)`, 100, 'x', 8);
            }

            // 2. Alternating Pattern (C·∫ßu ƒê·∫£o 1-1)
            const alternatingPercentage = checkAlternating(results);
            if (alternatingPercentage > 90 && results.length >= 4) { // Very strong alternating
                addPrediction("C·∫ßu ƒê·∫£o 1-1 (R·∫•t r√µ r√†ng)", alternatingPercentage, lastChar === 't' ? 'x' : 't', 11);
            } else if (alternatingPercentage > 75 && results.length >= 3) { // Strong alternating
                addPrediction("C·∫ßu ƒê·∫£o 1-1 (Xu h∆∞·ªõng m·∫°nh)", alternatingPercentage, lastChar === 't' ? 'x' : 't', 9);
            }

            // 3. Double Alternating (C·∫ßu K√©p 2-2)
            if (results.length >= 4) {
                if (getSequenceMatchPercentage('ttxx', results.slice(-4)) === 100) addPrediction("C·∫ßu K√©p 2-2 (TTXX)", 100, 't', 8);
                if (getSequenceMatchPercentage('xxtt', results.slice(-4)) === 100) addPrediction("C·∫ßu K√©p 2-2 (XXTT)", 100, 'x', 8);
            }
            if (results.length >= 6) {
                if (getSequenceMatchPercentage('ttxxtt', results.slice(-6)) === 100) addPrediction("C·∫ßu K√©p 2-2 (TTXXTT)", 100, 'x', 8);
                if (getSequenceMatchPercentage('xxttxx', results.slice(-6)) === 100) addPrediction("C·∫ßu K√©p 2-2 (XXTTXX)", 100, 't', 8);
            }

            // 4. C·∫ßu 3-1-1 (3 b·ªát, sau ƒë√≥ 1 ƒë·∫£o) or 1-3-1
            if (results.length >= 5) {
                if (getSequenceMatchPercentage('tttxt', results.slice(-5)) === 100) addPrediction("C·∫ßu 3-1-1 (TTTXT)", 100, 'x', 7);
                if (getSequenceMatchPercentage('xxxtx', results.slice(-5)) === 100) addPrediction("C·∫ßu 3-1-1 (XXXTAI)", 100, 't', 7);
                if (getSequenceMatchPercentage('txttt', results.slice(-5)) === 100) addPrediction("C·∫ßu 1-3-1 (TXTTAI)", 100, 'x', 7);
                if (getSequenceMatchPercentage('xtxxx', results.slice(-5)) === 100) addPrediction("C·∫ßu 1-3-1 (XTXXX)", 100, 't', 7);
            }

            // 5. C·∫ßu 1-2-3 and 3-2-1 (Ladder patterns)
            if (results.length >= 6) { 
                if (getSequenceMatchPercentage('txtttx', results.slice(-6)) === 100) addPrediction("C·∫ßu 1-2-3 (TXTTTX)", 100, 't', 6);
                if (getSequenceMatchPercentage('xtxxx', results.slice(-5)) === 100) addPrediction("C·∫ßu 1-2-3 (XTXXX)", 100, 't', 6); 
                if (getSequenceMatchPercentage('xxtttx', results.slice(-6)) === 100) addPrediction("C·∫ßu 2-3-1 (XXTTTX)", 100, 't', 6);
                if (getSequenceMatchPercentage('tttxxt', results.slice(-6)) === 100) addPrediction("C·∫ßu 3-2-1 (TTTXXT)", 100, 'x', 6);
            }

            // 6. C·∫ßu B·ªát Ng·∫Øt Qu√£ng (Interrupted Streaks) - e.g., TTTXTTT
            if (results.length >= 7) {
                if (results.slice(-7).match(/t{3}xt{3}/)) addPrediction("C·∫ßu b·ªát ng·∫Øt qu√£ng (T√†i)", 95, 't', 7);
                if (results.slice(-7).match(/x{3}tx{3}/)) addPrediction("C·∫ßu b·ªát ng·∫Øt qu√£ng (X·ªâu)", 95, 'x', 7);
            }

            // 7. C·∫ßu 3-2-1 (3 b·ªát, 2 b·ªát, 1 b·ªát)
            if (results.length >= 6) {
                if (getSequenceMatchPercentage('tttxxt', results.slice(-6)) === 100) addPrediction("C·∫ßu 3-2-1 (TTTXXT)", 100, 'x', 7);
                if (getSequenceMatchPercentage('xxxttx', results.slice(-6)) === 100) addPrediction("C·∫ßu 3-2-1 (XXXTTX)", 100, 't', 7);
            }

            // 8. C·∫ßu 1-2-1-2 (D√¢y chuy·ªÅn)
            if (results.length >= 6) {
                if (getSequenceMatchPercentage('txxtxx', results.slice(-6)) === 100) addPrediction("C·∫ßu 1-2-1-2 (TXXTXX)", 100, 't', 7);
                if (getSequenceMatchPercentage('xttxtt', results.slice(-6)) === 100) addPrediction("C·∫ßu 1-2-1-2 (XTTXTT)", 100, 'x', 7);
            }

            // 9. C·∫ßu 2-1-2-1 (D√¢y chuy·ªÅn ng∆∞·ª£c)
            if (results.length >= 6) {
                if (getSequenceMatchPercentage('ttxttx', results.slice(-6)) === 100) addPrediction("C·∫ßu 2-1-2-1 (TTXTTX)", 100, 'x', 7);
                if (getSequenceMatchPercentage('xxtxxt', results.slice(-6)) === 100) addPrediction("C·∫ßu 2-1-2-1 (XXTXXT)", 100, 't', 7);
            }

            // 10. C·∫ßu B·ªát L·∫≠t (Reverse Streak)
            if (results.length >= 7) {
                if (results.slice(-7).match(/t{4}x{3}/)) addPrediction("C·∫ßu b·ªát l·∫≠t (T√†i sang X·ªâu)", 90, 'x', 8);
                if (results.slice(-7).match(/x{4}t{3}/)) addPrediction("C·∫ßu b·ªát l·∫≠t (X·ªâu sang T√†i)", 90, 't', 8);
            }

            // 11. C·∫ßu Xen K·∫Ω D√†i (Extended Alternating)
            if (results.length >= 6) {
                const longerAlternating = checkAlternating(results.slice(-6));
                if (longerAlternating > 80 && alternatingPercentage <= 90) { 
                    addPrediction("C·∫ßu xen k·∫Ω d√†i (Lu√¢n phi√™n tr√™n 6 l∆∞·ª£t)", longerAlternating, lastChar === 't' ? 'x' : 't', 6);
                }
            }
            
            // --- C·∫¶U B·∫∫ (BREAK PATTERNS) ---
            // C·∫ßu B·∫ª Nh·∫π (Light Break) - Short streak followed by an immediate reversal
            // e.g., TTX, XXT (2 consecutive, then breaks)
            if (results.length >= 3) {
                if (lastChar === 't' && secondLastChar === 't' && thirdLastChar === 'x') { // ...XTT
                    addPrediction("C·∫ßu b·∫ª nh·∫π (2 T√†i sau X·ªâu)", 70, 'x', 6); // Predict X to continue break
                } else if (lastChar === 'x' && secondLastChar === 'x' && thirdLastChar === 't') { // ...TXX
                    addPrediction("C·∫ßu b·∫ª nh·∫π (2 X·ªâu sau T√†i)", 70, 't', 6); // Predict T to continue break
                }
            }

            // C·∫ßu B·∫ª M·∫°nh (Strong Break) - Longer streak followed by an immediate reversal
            // e.g., TTTX, XXXT (3 consecutive, then breaks)
            if (results.length >= 4) {
                if (lastChar === 't' && secondLastChar === 't' && thirdLastChar === 't' && fourthLastChar === 'x') { // ...XTTT
                    addPrediction("C·∫ßu b·∫ª m·∫°nh (3 T√†i sau X·ªâu)", 90, 'x', 9); // Higher priority break
                } else if (lastChar === 'x' && secondLastChar === 'x' && thirdLastChar === 'x' && fourthLastChar === 't') { // ...TXXX
                    addPrediction("C·∫ßu b·∫ª m·∫°nh (3 X·ªâu sau T√†i)", 90, 't', 9); // Higher priority break
                }
            }


            // --- Aggregate and Final Prediction ---
            let finalTaiScore = 0;
            let finalXiuScore = 0;

            // Sort by priority (descending) and then percentage (descending)
            potentialPredictions.sort((a, b) => {
                if (b.priority !== a.priority) {
                    return b.priority - a.priority;
                }
                return b.percentage - a.percentage;
            });

            // Consider only the top N predictions or those above a certain threshold
            const strongPredictions = potentialPredictions.filter(p => p.priority >= 5 && p.percentage >= 70);

            if (strongPredictions.length > 0) {
                strongPredictions.forEach(p => {
                    // Weighted score: percentage * priority
                    if (p.prediction === 't') {
                        finalTaiScore += (p.percentage / 100) * p.priority;
                    } else if (p.prediction === 'x') {
                        finalXiuScore += (p.percentage / 100) * p.priority;
                    }
                });
            } else {
                // Fallback: If no strong patterns, predict inverse of last result
                if (results.length > 0) {
                    addPrediction("D·ª± ƒëo√°n ng∆∞·ª£c l·∫°i (Kh√¥ng c√≥ c·∫ßu r√µ r√†ng)", 50, lastChar === 't' ? 'x' : 't', 1); // Low priority fallback
                    if (lastChar === 't') finalXiuScore += 0.5; // Small boost for X
                    else finalTaiScore += 0.5; // Small boost for T
                }
            }

            let finalPredictionText = "Kh√¥ng ch·∫Øc ch·∫Øn";
            let predictionColor = "#555";

            const scoreDifference = Math.abs(finalTaiScore - finalXiuScore);
            const totalScore = finalTaiScore + finalXiuScore;

            if (totalScore === 0) { 
                finalPredictionText = "Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu ho·∫∑c c·∫ßu ng·∫´u nhi√™n.";
                predictionColor = "#555";
            } else if (scoreDifference / totalScore > 0.4) { 
                if (finalTaiScore > finalXiuScore) {
                    finalPredictionText = "D·ª± ƒëo√°n: T√†i";
                    predictionColor = "#4CAF50";
                } else {
                    finalPredictionText = "D·ª± ƒëo√°n: X·ªâu";
                    predictionColor = "#f44336";
                }
            } else {
                if (results.length > 0) {
                     if (lastChar === 't') {
                        finalPredictionText = "C√≥ th·ªÉ l√† X·ªâu"; 
                        predictionColor = "#f44336";
                    } else {
                        finalPredictionText = "C√≥ th·ªÉ l√† T√†i"; 
                        predictionColor = "#4CAF50";
                    }
                } else {
                     finalPredictionText = "Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ d·ª± ƒëo√°n."; 
                     predictionColor = "#555";
                }
            }

            predictionDisplay.innerText = finalPredictionText;
            predictionDisplay.style.color = predictionColor;
        }

        // --- H√†m analyzePatterns() (ch·ªâ ƒë·ªÉ hi·ªÉn th·ªã c√°c c·∫ßu ƒë√£ nh·∫≠n di·ªán) ---
        function analyzePatterns() {
            patternsList.innerHTML = "";
            const currentPatterns = [];

            function checkConsecutive(char, count) {
                const regex = new RegExp(`${char}{${count}}$`);
                return regex.test(results);
            }

            function checkAlternating(subStr) {
                if (!subStr || subStr.length < 2) return 0;
                let matches = 0;
                for (let i = 0; i < subStr.length - 1; i++) {
                    if (subStr[i] !== subStr[i+1]) {
                        matches++;
                    }
                }
        </script>
  </div>
  <div id="tool2Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 2</h3><p>ƒê√¢y l√† n·ªôi dung tool 2.</p>
    <script>console.log("Tool 2 ƒëang ho·∫°t ƒë·ªông...");</script>
  </div>
  <div id="tool3Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 3</h3><p>ƒê√¢y l√† n·ªôi dung tool 3.</p>
    <script>console.log("Tool 3 ƒëang ho·∫°t ƒë·ªông...");</script>
  </div>
  <div id="tool4Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 4</h3><p>ƒê√¢y l√† n·ªôi dung tool 4.</p>
    <script>console.log("Tool 4 ƒëang ho·∫°t ƒë·ªông...");</script>
  </div>
  <div id="tool5Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 5</h3><p>ƒê√¢y l√† n·ªôi dung tool 5.</p>
    <script>console.log("Tool 5 ƒëang ho·∫°t ƒë·ªông...");</script>
  </div>
  <div id="tool6Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 6</h3><p>ƒê√¢y l√† n·ªôi dung tool 6.</p>
    <script>console.log("Tool 6 ƒëang ho·∫°t ƒë·ªông...");</script>
  </div>
  <div id="tool7Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 7</h3><p>ƒê√¢y l√† n·ªôi dung tool 7.</p>
    <script>console.log("Tool 7 ƒëang ho·∫°t ƒë·ªông...");</script>
  </div>
  <div id="tool8Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 8</h3><p>ƒê√¢y l√† n·ªôi dung tool 8.</p>
    <script>console.log("Tool 8 ƒëang ho·∫°t ƒë·ªông...");</script>
  </div>
  <div id="tool9Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 9</h3><p>ƒê√¢y l√† n·ªôi dung tool 9.</p>
    <script>console.log("Tool 9 ƒëang ho·∫°t ƒë·ªông...");</script>
  </div>
  <div id="tool10Div" class="tool-content" style="display:none;">
    <h3>üîß Tool 10</h3><p>ƒê√¢y l√† n·ªôi dung tool 10.</p>
    <script>console.log("Tool 10 ƒëang ho·∫°t ƒë·ªông...");</script>
  </div>
</div>

<div id="note">
  ƒê√ÇY L√Ä TOOL ANH EM NH√Ä KV, KHUY·∫æN C√ÅO ANH EM ƒê·∫∂T C∆Ø·ª¢C √çT B·ªûI V√å TOOL KH√Å L·ªé N√äN ANH EM M·∫§T TI·ªÄN TH√å ƒê·ª™NG C√ì S·ª¶A ·∫≤NGGG !!!!!!!!
</div>

<script>
  const keysURL = "https://raw.githubusercontent.com/adminvienkey26109/trinhngocvientx/refs/heads/main/keys.json";
  const status = document.getElementById("status");
  const gameMenu = document.getElementById("gameMenu");
  const gamesButtons = document.getElementById("gamesButtons");
  const logoutBtn = document.getElementById("logoutBtn");
  const countdownElem = document.getElementById("countdown");
  const userKeyInput = document.getElementById("userKey");

  const toolDivs = [
    "tool1Div", "tool2Div", "tool3Div", "tool4Div", "tool5Div",
    "tool6Div", "tool7Div", "tool8Div", "tool9Div", "tool10Div"
  ];

  function toggleAdminContacts() {
    const cont = document.getElementById("adminContacts");
    cont.style.display = cont.style.display === "block" ? "none" : "block";
  }

  function showTool(index) {
    for (let i = 0; i < toolDivs.length; i++) {
      document.getElementById(toolDivs[i]).style.display = i === index ? "block" : "none";
    }
    document.getElementById("toolContainer").scrollIntoView({ behavior: "smooth" });
  }

  function showGameMenu(expireDate) {
    gameMenu.style.display = "flex";
    userKeyInput.style.display = "none";
    document.querySelector("button[onclick='checkKey()']").style.display = "none";
    logoutBtn.style.display = "inline-block";

    gamesButtons.innerHTML = "";
    for (let i = 0; i < 10; i++) {
      const btn = document.createElement("button");
      btn.className = "game-btn";
      btn.innerHTML = `<span>Tool ${i + 1}</span>`;
      btn.onclick = () => showTool(i);
      gamesButtons.appendChild(btn);
    }

    if (expireDate) {
      startCountdown(new Date(expireDate));
    }
  }

  let countdownInterval;
  function startCountdown(expireDate) {
    clearInterval(countdownInterval);
    function updateCountdown() {
      const now = new Date();
      const diff = expireDate - now;
      if (diff <= 0) {
        clearInterval(countdownInterval);
        alert("‚è∞ Key c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n v√† b·ªã ban!");
        logout();
        return;
      }
      const d = Math.floor(diff / (1000 * 60 * 60 * 24));
      const h = Math.floor((diff / (1000 * 60 * 60)) % 24);
      const m = Math.floor((diff / (1000 * 60)) % 60);
      const s = Math.floor((diff / 1000) % 60);
      countdownElem.textContent = `Key h·∫øt h·∫°n sau: ${d} ng√†y ${h} gi·ªù ${m} ph√∫t ${s} gi√¢y`;
    }
    updateCountdown();
    countdownInterval = setInterval(updateCountdown, 1000);
  }

  async function checkKey() {
    const inputKey = userKeyInput.value.trim();
    if (!inputKey) {
      status.style.color = "red";
      status.textContent = "‚ùå Vui l√≤ng nh·∫≠p key!";
      return;
    }
    status.textContent = "üîÑ ƒêang ki·ªÉm tra key...";
    status.style.color = "white";

    try {
      const res = await fetch(keysURL);
      const data = await res.json();
      const keyObj = data.keys.find(k => k.key === inputKey);
      if (!keyObj) {
        status.style.color = "red";
        status.textContent = "‚ùå Key kh√¥ng h·ª£p l·ªá.";
        return;
      }
      const expireDate = keyObj.expiresAt ? new Date(keyObj.expiresAt) : null;
      const now = new Date();
      if (expireDate && expireDate < now) {
        status.style.color = "red";
        status.textContent = "‚ùå Key c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n v√† b·ªã ban!";
        return;
      }
      localStorage.setItem("userKey", inputKey);
      keyObj.expiresAt
        ? localStorage.setItem("keyExpire", keyObj.expiresAt)
        : localStorage.removeItem("keyExpire");

      status.style.color = "green";
      status.textContent = "‚úÖ Key h·ª£p l·ªá! ƒêang chuy·ªÉn h∆∞·ªõng...";
      setTimeout(() => showGameMenu(keyObj.expiresAt), 1000);

    } catch (e) {
      status.style.color = "red";
      status.textContent = "‚ùå L·ªói khi ki·ªÉm tra key.";
      console.error(e);
    }
  }

  function logout() {
    localStorage.removeItem("userKey");
    localStorage.removeItem("keyExpire");
    location.reload();
  }

  window.onload = () => {
    const savedKey = localStorage.getItem("userKey");
    const savedExpire = localStorage.getItem("keyExpire");
    if (savedKey) {
      const expireDate = savedExpire ? new Date(savedExpire) : null;
      if (expireDate && expireDate < new Date()) {
        alert("‚è∞ Key c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n v√† b·ªã ban!");
        logout();
      } else {
        showGameMenu(savedExpire);
      }
    }
  };
</script>

</body>
</html>
